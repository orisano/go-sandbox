package main

import (
	"bufio"
	"encoding/gob"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/orisano/subflag"
	"github.com/pkg/errors"
)

type BuildCommand struct {
	root   string
	output string
}

func (c *BuildCommand) FlagSet() *flag.FlagSet {
	fs := flag.NewFlagSet("build", flag.ExitOnError)
	fs.StringVar(&c.root, "d", ".", "root directory")
	fs.StringVar(&c.output, "o", "filter.gob", "output filter binary path")
	return fs
}

func (c *BuildCommand) Run(args []string) error {
	var paths [][]rune
	err := filepath.Walk(c.root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			if info.Name() == "vendor" {
				return filepath.SkipDir
			}
			return nil
		}
		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}
		ok, err := isGeneratedFile(path)
		if err != nil {
			return errors.Wrap(err, "failed to check generated file")
		}
		if ok {
			paths = append(paths, []rune(path))
		}
		return nil
	})
	if err != nil {
		return errors.Wrap(err, "failed to walk files")
	}

	m, err := buildMachine(paths)
	if err != nil {
		return errors.Wrap(err, "failed to build aho corasick")
	}

	f, err := os.Create(c.output)
	if err != nil {
		return errors.Wrap(err, "failed to create machine")
	}
	defer f.Close()

	if err := gob.NewEncoder(f).Encode(m); err != nil {
		return errors.Wrap(err, "failed to encode machine")
	}

	return nil
}

func isGeneratedFile(path string) (bool, error) {
	f, err := os.Open(path)
	if err != nil {
		return false, errors.Wrap(err, "failed to open file")
	}
	defer f.Close()
	s := bufio.NewScanner(f)
	if !s.Scan() {
		if err := s.Err(); err != nil {
			return false, errors.Wrap(err, "failed to scan file")
		}
		return false, nil
	}
	return strings.HasPrefix(s.Text(), "// Code generated by"), nil
}

type ApplyCommand struct {
	filter string
	input  string
}

func (c *ApplyCommand) FlagSet() *flag.FlagSet {
	fs := flag.NewFlagSet("apply", flag.ExitOnError)
	fs.StringVar(&c.filter, "f", "filter.gob", "filter binary path")
	fs.StringVar(&c.input, "i", "-", "input file")
	return fs
}

func (c *ApplyCommand) Run(args []string) error {
	m, err := loadMachine(c.filter)
	if err != nil {
		return errors.Wrap(err, "failed to load machine")
	}
	var r io.Reader
	if c.input == "-" {
		r = os.Stdin
	} else {
		f, err := os.Open(c.input)
		if err != nil {
			return errors.Wrap(err, "failed to open input")
		}
		defer f.Close()
		r = f
	}
	s := bufio.NewScanner(r)
	for s.Scan() {
		line := s.Text()
		if !m.Contains([]rune(line)) {
			fmt.Println(line)
		}
	}
	if err := s.Err(); err != nil {
		return errors.Wrap(err, "failed to scan")
	}
	return nil
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("genfilter: ")
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	return subflag.SubCommand(os.Args[1:], []subflag.Command{
		&ApplyCommand{},
		&BuildCommand{},
	})
}
